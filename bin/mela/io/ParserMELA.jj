options {
  STATIC = false;
}

PARSER_BEGIN(MELAparser)

package mela.io;

import java.util.HashMap;
import java.util.function.BiFunction;
import mela.model.LocationManager;
import mela.model.Model;


public class MELAparser {
       
    public MELAparser() {
        this(new java.io.StringReader(""));
    }

    public Model parseFromString( String modelDef ) throws ParseException, TokenMgrError, NumberFormatException {
        this.ReInit(new java.io.StringReader(modelDef));
        return Input();
    }

        public Model parseFromFile( String filename ) throws ParseException, TokenMgrError, NumberFormatException {
        try { this.ReInit(new java.io.FileReader(filename)); }
        catch(java.io.IOException e) {throw new ParseException("Error while opening file " + filename + ": " + e); }
        return Input();
    }

}

PARSER_END(MELAparser)

/***************************************************************
SKIP
***************************************************************/

<DEFAULT,RESET,ID> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

 /* LITERALS */
TOKEN : { < #INTEGER: ("-")? ["0"-"9"] (["0"-"9"])* > }
TOKEN : { < #FLOAT:
                            ("-")?  (["0"-"9"])+ "." (["0"-"9"])*
                            | ("-")?  "." (["0"-"9"])+
                    > }
TOKEN : { < #FLOAT_SCIENTIFIC:
                             ("-")? (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)
                            |  ("-")? "." (["0"-"9"])+ (<EXPONENT>)
                            |  ("-")? (["0"-"9"])+ <EXPONENT>
                    > }
TOKEN : { < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ > }
TOKEN: { < #LETTER: ["A"-"Z","a"-"z"] > }
TOKEN: { < #DIGIT: ["0"-"9"] > }

TOKEN: { < #WORD: (["A"-"Z","a"-"z"])+ > }

	
/*
IDENTIFIERS
*/

<DEFAULT> TOKEN : { <SECTION_SPACE : "#Space" > }
<DEFAULT> TOKEN : { <SECTION_PARAM : "#Parameters" > }
<DEFAULT> TOKEN : { <SECTION_AGENTS : "#Agents" > }
<DEFAULT> TOKEN : { <SECTION_ENV : "#Environment" > }
<DEFAULT> TOKEN : { <SECTION_INIT : "#Initial conditions" > }

<DEFAULT> TOKEN : { <VERTICES : "L" > }
<DEFAULT> TOKEN : { <EDGES : "E" > }

<DEFAULT> TOKEN : { <KEYWORD_GRAPH : "Graph" > }
<DEFAULT> TOKEN : { <KEYWORD_ONED : "OneD" > }
<DEFAULT> TOKEN : { <KEYWORD_TWOD : "TwoD" > }
<DEFAULT> TOKEN : { <KEYWORD_THREED : "ThreeD" > }

<DEFAULT> TOKEN : { <KEYWORD_BOUNDARY : "#Boundary" > }
<DEFAULT> TOKEN : { <KEYWORD_PERIODIC : "periodic" > }
<DEFAULT> TOKEN : { <KEYWORD_BOUNCING : "bouncing" > }

<DEFAULT> TOKEN : { <KEYWORD_LOC : "l" > }
<DEFAULT> TOKEN : { <KEYWORD_NEIGH : "N" > }
<DEFAULT> TOKEN : { <KEYWORD_ALL : "all" > }

<DEFAULT> TOKEN : { <EOL : ";" > }
<DEFAULT> TOKEN : { <PLUS : "+" > }
<DEFAULT> TOKEN : { <DOT : "." > }
<DEFAULT> TOKEN : { <SEMICOLON : ":" > }
<DEFAULT> TOKEN : { <DEFINE : ":=" > }

<DEFAULT> TOKEN : { <ASSIGN : "=" >}
<DEFAULT> TOKEN : { <LSQ : "[" >}
<DEFAULT> TOKEN : { <RSQ : "]" >}
<DEFAULT> TOKEN : { <LR : "(" > }
<DEFAULT> TOKEN : { <RR : ")" > }
<DEFAULT> TOKEN : { <QUO : "\"" > }
<DEFAULT> TOKEN : { <SQUO : "\'" > }
<DEFAULT> TOKEN : { <EXCL : "!" > }
<DEFAULT> TOKEN : { <LBRAC : "{" > }
<DEFAULT> TOKEN : { <RBRAC : "}" > }

<DEFAULT> TOKEN : { <COMMA : "," >}
<DEFAULT> TOKEN : { <LANG : "<" > }
<DEFAULT> TOKEN : { <RANG : ">" > }
<DEFAULT> TOKEN : { <PARALLEL : "||" > }

<DEFAULT> TOKEN : { <TRIANGLE : "|>" > }

<DEFAULT> TOKEN : { <DASH : "-" > }

<DEFAULT> TOKEN : { <UP : ">>" > }
<DEFAULT> TOKEN : { <DOWN : "<<" > }

/*<DEFAULT> TOKEN: { <MELASYMBOL: < DOT > > }*/

<DEFAULT> TOKEN : {<INT : <INTEGER> > }
<DEFAULT> TOKEN : {<DOUBLE : <FLOAT>|<FLOAT_SCIENTIFIC> > }
<DEFAULT> TOKEN: { <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|"_"|"$"|"#")*> }

/*<DEFAULT> TOKEN: { <UPDATE_LOC: <WORD>> } */

<MATH> TOKEN : { <MATH_EXPR : (<DIGIT> | <SYMBOL> | <SPACE> | <M_AND> | <M_OR> | <M_LINER> | <M_LINEN> | <SQUO>)+ > : DEFAULT }
<MATH> TOKEN : { <#SPACE : " " | "\t"> }
<MATH> TOKEN : { <#M_AND : "&&" > }
<MATH> TOKEN : { <#M_OR : "|"> }
<MATH> TOKEN : { <#M_LINER : "\r"> }
<MATH> TOKEN : { <#M_LINEN : "\n"> }


TOKEN : { <#SYMBOL : [".", "=", "+", "-", "*", "/", "%", "^", "(", ")", "!", "<", ">", ",", "_", "[","]" ]> }
TOKEN : { <#PARAM_SYMBOL : [".", "+", "-", "*", "/", "%", "^" ]> }


/***********************************************
GRAMMAR RULES
***********************************************/

/*********
MODEL STRUCTURE
*********/

Model Input() throws NumberFormatException, RuntimeException, ParseException :
{
    Model m = new Model();    
    LocationManager lm;
    HashMap<String,Double> parameters = new HashMap<String,Double>();
}
{   <SECTION_SPACE>
	<SEMICOLON>
   	lm = SpaceStructure()
   	{ m.setLocationManager(lm); }
    <SECTION_PARAM>
    (
      Param( parameters )
    )*  
   <SECTION_INIT>

{

//    not sure why this is not working - I added manually to the generated parser

//    HashMap<Integer,HashMap<Integer,Integer>> alllocationMap = Init(m);
//    BiFunction<Integer,Integer,Integer> initCond = (x, y) -> {
//    Integer num = alllocationMap.getOrDefault( x , new HashMap<Integer,Integer>() ).getOrDefault( y , 0 );
//    return num;};
//    m.setBiFunction( initCond );

  
}
   

   {return m; }
    <EOF>
}

/*********
SPACE
*********/

LocationManager SpaceStructure() throws NumberFormatException, RuntimeException, ParseException :
{Token spaceKey=null;
 LocationManager lm = new LocationManager();}
{   
    [   
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_GRAPH >
        lm=setGraph() { return lm; }
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_ONED >
        lm=setOneD() { return lm; }
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_TWOD >
        lm = setTwoD() { return lm; }
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_THREED >
        lm = setThreeD() { return lm; }
    ]
    {
      return lm;
    }   
}


LocationManager setGraph() throws NumberFormatException, RuntimeException, ParseException :
{
  Token v, v1, e, e1;
  LocationManager lm = new LocationManager();
}
{   < VERTICES >
    < ASSIGN >
    < LBRAC >
    v = <INT>
    { int vValue = Integer.parseInt(v.image);
      String name = lm.createLocationName(vValue);
      lm.createLocation(name); }
    (
       <COMMA>
       v1 = <INT>
    { int v1Value = Integer.parseInt(v1.image);
      String name1 = lm.createLocationName(v1Value);
      lm.createLocation(name1); }
    )*
    < RBRAC >
    < EDGES >
    <ASSIGN>
    <LBRAC>
     <LBRAC>
     e = <INT>
     {if (!(lm.locationInLocationManager("["+e+"]"))){
    	 throw new Error("Location " +  e+"" + " is not defined.");
     }}
     <COMMA>
     e1 = <INT>
     {if (!(lm.locationInLocationManager("["+e1+"]"))){
    	 throw new Error("Location " +  e1+"" + " is not defined.");
     }}
     <RBRAC>
     { lm.addEdge(lm.getLocation("["+e+"]"), lm.getLocation("["+e1+"]")); }
     ( 
       <COMMA>
       <LBRAC>
       e = <INT>
       {if (!(lm.locationInLocationManager("["+e+"]"))){
    	 throw new Error("Location " +  e+"" + " is not defined.");
     }}
       <COMMA>
       e1 = <INT>
      {if (!(lm.locationInLocationManager("["+e1+"]"))){
    	 throw new Error("Location " +  e1+"" + " is not defined.");
     }}
       <RBRAC>
    { lm.addEdge(lm.getLocation("["+e+"]"), lm.getLocation("["+e1+"]")); }     
       )*
     <RBRAC>
     {  return lm; }
}

LocationManager setOneD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x;
    Boolean boundaryChoice;
}
{   <LR>
    x = <INT>
   <RR>
   <KEYWORD_BOUNDARY >
   < SEMICOLON >
   boundaryChoice = boundary()
   {int xValue = Integer.parseInt(x.image);
    LocationManager lm = new LocationManager();
    return lm.buildGridOne( xValue, boundaryChoice );}
}

Boolean boundary() throws NumberFormatException, RuntimeException, ParseException :
{Token spaceKey=null;}
{   
    [   
        LOOKAHEAD(1)
        spaceKey = < KEYWORD_PERIODIC >
        { return true; }
        |
        LOOKAHEAD(1)
        spaceKey = < KEYWORD_BOUNCING >
        { return false; }
    ] 
}

LocationManager setTwoD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x, y;
    Boolean boundaryChoice;
}
{   <LR>
    x = <INT>
    < COMMA >
    y = < INT >
   <RR>
   <KEYWORD_BOUNDARY >
   < SEMICOLON >
   boundaryChoice = boundary()
    {int xValue = Integer.parseInt(x.image);
    int yValue = Integer.parseInt(y.image);
    LocationManager lm = new LocationManager();
    return lm.buildGridTwo( xValue, yValue, boundaryChoice );}
}

LocationManager setThreeD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x, y, z;
    Boolean boundaryChoice;
}
{   <LR>
    x = <INT>
    < COMMA >
    y = < INT >
    < COMMA >
    z = < INT >
   <RR>
   <KEYWORD_BOUNDARY >
   < SEMICOLON >
   boundaryChoice = boundary()
   {int xValue = Integer.parseInt(x.image);
    int yValue = Integer.parseInt(y.image);
    int zValue = Integer.parseInt(z.image);
    LocationManager lm = new LocationManager();
    return lm.buildGridThree( xValue, yValue, zValue, boundaryChoice);}
}

/*********
PARAMETERS
*********/

void Param( HashMap<String,Double> parameters ) throws NumberFormatException, RuntimeException, ParseException :
{
    Token t1,t2;    
}
{		
    t1 = <IDENTIFIER>
    <ASSIGN>
    t2 = <DOUBLE> 
    <EOL>
    {double value = Double.parseDouble(t2.image);
    String name = t1.image;
     if (parameters.containsKey(name)){
    	 throw new Error("Parameter " +  name + " already defined.");
     }else{
     parameters.put( name, value ); } }
}


/*********
INITIAL CONDITIONS
*********/


//BiFunction<Integer,Integer,Integer>  Init( Model m ) throws NumberFormatException, RuntimeException, ParseException :
HashMap<Integer,HashMap<Integer,Integer>> Init( Model m ) throws NumberFormatException, RuntimeException, ParseException :

{  
HashMap<Integer,HashMap<Integer,Integer>> allLocationMap = new HashMap<Integer,HashMap<Integer,Integer>>();
}
{  
    InitAgent(m, allLocationMap ) 
    (
        <PARALLEL> 
        InitAgent(m, allLocationMap ) 
    )*
{

  
  return allLocationMap;
}
  
}    


void InitAgent( Model m , HashMap<Integer,HashMap<Integer,Integer>> allocationMap  ) throws NumberFormatException, RuntimeException, ParseException :
{    
   int agentIndex = 0;
   int locationIndex = 0;
   String locationName = "[";
   Token t, x, y, z, n;
}
{
    t = <IDENTIFIER> 
    (
    <LR>
    x = <INT> { locationName += x; }
    (
       <COMMA>
    y = <INT> { locationName += ", "+y; }
    (
       <COMMA>
    z = <INT> { locationName += ", "+z; }
    )?
    )?   
    <RR>
    { locationName += "]";
      if (m.getLocationManager().getLocationIndex(locationName) != -1){
    	  locationIndex = m.getLocationManager().getLocationIndex(locationName);
      }else{
    	  throw new Error("Location  " +  locationName + " does not exist."); 
      };
      locationIndex = m.getLocationManager().getLocationIndex(locationName); }
    )?
    <LSQ>
    n = <INT>
    {int nValue = Integer.parseInt(n.image);}
    <RSQ>
    { 
    HashMap<Integer,Integer> internalMap = allocationMap.get( agentIndex );
	if (internalMap==null) {
		internalMap = new HashMap<Integer,Integer>();
		allocationMap.put( agentIndex , internalMap );
	}
	internalMap.put( locationIndex , nValue );
    }
}

