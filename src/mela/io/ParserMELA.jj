options {
  STATIC = false;
}

PARSER_BEGIN(MELAparser)

package mela.io;

import java.util.HashMap;
import java.util.function.BiFunction;
import mela.model.LocationManager;
import mela.model.Model;


public class MELAparser {
       
    public MELAparser() {
        this(new java.io.StringReader(""));
    }

    public Model parseFromString( String modelDef ) throws ParseException, TokenMgrError, NumberFormatException {
        this.ReInit(new java.io.StringReader(modelDef));
        return Input();
    }

        public Model parseFromFile( String filename ) throws ParseException, TokenMgrError, NumberFormatException {
        try { this.ReInit(new java.io.FileReader(filename)); }
        catch(java.io.IOException e) {throw new ParseException("Error while opening file " + filename + ": " + e); }
        return Input();
    }

}

PARSER_END(MELAparser)

/***************************************************************
SKIP
***************************************************************/

<DEFAULT,RESET,ID> SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"

  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/***************************************************************
TOKENS
***************************************************************/

 /* LITERALS */
TOKEN : { < #INTEGER: ("-")? ["0"-"9"] (["0"-"9"])* > }
TOKEN : { < #FLOAT:
                            ("-")?  (["0"-"9"])+ "." (["0"-"9"])*
                            | ("-")?  "." (["0"-"9"])+
                    > }
TOKEN : { < #FLOAT_SCIENTIFIC:
                             ("-")? (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)
                            |  ("-")? "." (["0"-"9"])+ (<EXPONENT>)
                            |  ("-")? (["0"-"9"])+ <EXPONENT>
                    > }
TOKEN : { < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ > }
TOKEN: { < #LETTER: ["A"-"Z","a"-"z"] > }
TOKEN: { < #DIGIT: ["0"-"9"] > }

TOKEN: { < #WORD: (["A"-"Z","a"-"z"])+ > }

	
/*
IDENTIFIERS
*/

<DEFAULT> TOKEN : { <SECTION_SPACE : "#Space" > }
<DEFAULT> TOKEN : { <SECTION_PARAM : "#Parameters" > }
<DEFAULT> TOKEN : { <SECTION_AGENTS : "#Agents" > }
<DEFAULT> TOKEN : { <SECTION_ENV : "#Environment" > }
<DEFAULT> TOKEN : { <SECTION_INIT : "#Initial conditions" > }

<DEFAULT> TOKEN : { <VERTICES : "L" > }
<DEFAULT> TOKEN : { <EDGES : "E" > }

<DEFAULT> TOKEN : { <KEYWORD_GRAPH : "Graph" > }
<DEFAULT> TOKEN : { <KEYWORD_ONED : "OneD" > }
<DEFAULT> TOKEN : { <KEYWORD_TWOD : "TwoD" > }
<DEFAULT> TOKEN : { <KEYWORD_THREED : "ThreeD" > }

<DEFAULT> TOKEN : { <KEYWORD_LOC : "l" > }
<DEFAULT> TOKEN : { <KEYWORD_NEIGH : "N" > }
<DEFAULT> TOKEN : { <KEYWORD_ALL : "all" > }

<DEFAULT> TOKEN : { <EOL : ";" > }
<DEFAULT> TOKEN : { <PLUS : "+" > }
<DEFAULT> TOKEN : { <DOT : "." > }
<DEFAULT> TOKEN : { <SEMICOLON : ":" > }
<DEFAULT> TOKEN : { <DEFINE : ":=" > }

<DEFAULT> TOKEN : { <ASSIGN : "=" >}
<DEFAULT> TOKEN : { <LSQ : "[" >}
<DEFAULT> TOKEN : { <RSQ : "]" >}
<DEFAULT> TOKEN : { <LR : "(" > }
<DEFAULT> TOKEN : { <RR : ")" > }
<DEFAULT> TOKEN : { <QUO : "\"" > }
<DEFAULT> TOKEN : { <SQUO : "\'" > }
<DEFAULT> TOKEN : { <EXCL : "!" > }
<DEFAULT> TOKEN : { <LBRAC : "{" > }
<DEFAULT> TOKEN : { <RBRAC : "}" > }

<DEFAULT> TOKEN : { <COMMA : "," >}
<DEFAULT> TOKEN : { <LANG : "<" > }
<DEFAULT> TOKEN : { <RANG : ">" > }
<DEFAULT> TOKEN : { <PARALLEL : "||" > }

<DEFAULT> TOKEN : { <TRIANGLE : "|>" > }

<DEFAULT> TOKEN : { <DASH : "-" > }

<DEFAULT> TOKEN : { <UP : ">>" > }
<DEFAULT> TOKEN : { <DOWN : "<<" > }

/*<DEFAULT> TOKEN: { <MELASYMBOL: < DOT > > }*/

<DEFAULT> TOKEN : {<INT : <INTEGER> > }
<DEFAULT> TOKEN : {<DOUBLE : <FLOAT>|<FLOAT_SCIENTIFIC> > }
<DEFAULT> TOKEN: { <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|"_"|"$"|"#")*> }

/*<DEFAULT> TOKEN: { <UPDATE_LOC: <WORD>> } */

<MATH> TOKEN : { <MATH_EXPR : (<DIGIT> | <SYMBOL> | <SPACE> | <M_AND> | <M_OR> | <M_LINER> | <M_LINEN> | <SQUO>)+ > : DEFAULT }
<MATH> TOKEN : { <#SPACE : " " | "\t"> }
<MATH> TOKEN : { <#M_AND : "&&" > }
<MATH> TOKEN : { <#M_OR : "|"> }
<MATH> TOKEN : { <#M_LINER : "\r"> }
<MATH> TOKEN : { <#M_LINEN : "\n"> }


TOKEN : { <#SYMBOL : [".", "=", "+", "-", "*", "/", "%", "^", "(", ")", "!", "<", ">", ",", "_", "[","]" ]> }
TOKEN : { <#PARAM_SYMBOL : [".", "+", "-", "*", "/", "%", "^" ]> }


/***********************************************
GRAMMAR RULES
***********************************************/

/*********
MODEL STRUCTURE
*********/

Model Input() throws NumberFormatException, RuntimeException, ParseException :
{
    Model m = new Model();    
    LocationManager lm;
    HashMap<String,Double> parameters = new HashMap<String,Double>();
}
{   <SECTION_SPACE>
	<SEMICOLON>
   	lm = SpaceStructure() { m.setLocationManager(lm); }
    <SECTION_PARAM>
    (
      Param( parameters )
    )*  
   <SECTION_INIT>
   {return m; }
    <EOF>
}

/*********
SPACE
*********/

LocationManager SpaceStructure() throws NumberFormatException, RuntimeException, ParseException :
{Token spaceKey=null;
 LocationManager lm = new LocationManager();}
{   
    [   
        LOOKAHEAD(2)
        < KEYWORD_GRAPH >
        lm=setGraph() { return lm; }
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_ONED >
        {setOneD();}
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_TWOD >
        {setTwoD();}
        |
        LOOKAHEAD(2)
        spaceKey = < KEYWORD_THREED >
        {setThreeD();}
    ]
    {
      return lm;
    }   
}


LocationManager setGraph() throws NumberFormatException, RuntimeException, ParseException :
{
  Token v, v1, e, e1;
  LocationManager lm = new LocationManager();
}
{   < VERTICES >
    < ASSIGN >
    < LBRAC >
    v = <INT>
    { lm.createLocation(v+""); }
    (
       <COMMA>
       v1 = <INT>
    { lm.createLocation(v+""); }
    )*
    < RBRAC >
    < EOL >
    < EDGES >
    <ASSIGN>
    <LBRAC>
     <LBRAC>
     e = <INT>
     <COMMA>
     e1 = <INT>
     <RBRAC>
     ( 
       <COMMA>
       <LBRAC>
       e = <INT>
       <COMMA>
       e1 = <INT>
       )*
     <RBRAC>
     < EOL >
     {  return lm; }
}

void setOneD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x;
}
{   <LR>
    x = <INT>
   <RR>
}

void setTwoD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x, y;
}
{   <LR>
    x = <INT>
    < COMMA >
    y = < INT >
   <RR>
}

void setThreeD()throws NumberFormatException, RuntimeException, ParseException :
{
    Token x, y, z;
}
{   <LR>
    x = <INT>
    < COMMA >
    y = < INT >
    < COMMA >
    z = < INT >
   <RR>
}

/*********
PARAMETERS
*********/

void Param( HashMap<String,Double> parameters ) throws NumberFormatException, RuntimeException, ParseException :
{
    Token t1,t2;    
}
{		
    t1 = <IDENTIFIER>
    <ASSIGN>
    t2 = <DOUBLE> 
    <EOL>    
}


/*********
INITIAL CONDITIONS
*********/


//BiFunction<Integer,Integer,Integer>  Init( Model m ) throws NumberFormatException, RuntimeException, ParseException :
void Init( Model m ) throws NumberFormatException, RuntimeException, ParseException :

{  
HashMap<Integer,HashMap<Integer,Integer>> allocationMap = new HashMap<Integer,HashMap<Integer,Integer>>();
}
{  
    InitAgent(m, allocationMap ) 
    (
        <PARALLEL> 
        InitAgent(m, allocationMap ) 
    )*
//{
//
//  
//  BiFunction<Integer,Integer,Integer> initCond = (x, y) -> {
//			Integer num = allocationMap.getOrDefault( x , new HashMap<Integer,Integer>() ).getOrDefault( y , 0 );
//			return num;
//		};
//		return initCond;
//}
  
}    


void InitAgent( Model m , HashMap<Integer,HashMap<Integer,Integer>> allocationMap  ) throws NumberFormatException, RuntimeException, ParseException :
{    
   int agentIndex = 0;
   int locationIndex = 0;
   String locationName = "";
   Token t, x, y, z, n;
}
{
    t = <IDENTIFIER> 
    (
    <LR>
    x = <INT> { locationName += x; }
    (
       <COMMA>
    y = <INT> { locationName += ","+y; }
    (
       <COMMA>
    z = <INT> { locationName += ","+z; }
    )?
    )?    
    <RR> { locationIndex = m.getLocationManager().getLocationIndex(locationName); }
    )?
    <LSQ>
    n = <INT>
    {int nValue = Integer.parseInt(n.image);}
    <RSQ>
    { 
    HashMap<Integer,Integer> internalMap = allocationMap.get( agentIndex );
	if (internalMap==null) {
		internalMap = new HashMap<Integer,Integer>();
		allocationMap.put( agentIndex , internalMap );
	}
	internalMap.put( locationIndex , nValue );
    }
}

